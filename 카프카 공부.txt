이벤트 기반 아키텍처
Domain Event: 도메인에 영향을 주는 관심정보 

이벤트 브로커: Kafka, 키네시스
- 이벤트(또는 메세지)라고 불리는 레코드를 딱 하나만 보관하고 -> 인덱스를 통해 개별 액세스를 관리함
- 업무상 필요한 시간동안 이벤트를 보관할 수 있음
- 서비스에서 나오는 이벤트를 데이터베이스에 저장하듯 이벤트 브로커의 큐에 저장함
	- 딱 한 번 일어난 이벤트 데이터를 브로커에 저장함으로서 단일 진실 공급원으로 사용 가능
	- 장애가 발생했을 대 장애가 일어난 지점부터 재처리할 수 있음
	- 많은 양의 실시간 스트림 데이터를 효과적으로 처리할 수 있음
- 메세지 브로커로서의 역할 O

메세지 브로커: RedisQ / RabbitMQ
- 대규모 메세지 기반 미들웨어(서비스하는 애플리케이션들을 보다 효율적으로 아키텍처들을 연결하는 요소로 작동하는 소프트웨어, 메세징 플랫폼/인증 플랫폼/데이터베이스 등) 아키텍처에서 사용
- 메세지 브로커에 있는 큐에 데이터를 보내고 받는 producer와 consumer를 통해 메세지를 통신, 네트워크를 맺는 용도로 사용
- 메세지를 받아 적절히 처리하고 나면 즉시 또는 잛은 시간 내에 삭제되는 구조
- 이벤트 브로커로서의 역할 X

RabbitMQ

< Kafka >
대용량 트래픽을 처리해야 할 때에 
데이터 스트림을 실시간으로 처리하고 저장하기 위해 고안
많은 양의 데이터를 효율적으로 처리
대규모 데이터 파이프라인 , 실시간 분석 등...에 사용됨
=> 아주 유연한 큐~라고 보면 됨

producer -> kafka cluster -> consumer
(처리해야 할 일을 생산하는 생산자) -> (처리할 것을 저장하는 클러스터) -> (처리해야 할 일을 처리하는 역할)
topic: 카프카가 사용하는 이벤트의 분류 단위
- 일반적인 AMQP와는 다르게 동작?함
- 데이터베이스의 테이블이나 파일시스템의 폴더와 유사한 성질
- Producer 가 넣고 Consumer가 가져감
- 클릭로그/send sms/Location log 등 이름을 가질 수 있음
- 하나의 포틱은 여러개의 파티션으로 구성, 하나의 파티션은 내부로 데이터가 큐처럼 적재됨. 컨슈머가 데이터를 가져가도 데이터는 삭제되지 않음(=동일 데이터를 두 번 처리할 수 있음)
 

Broker: 데이터의 저장/전달 관리 => 실질적으로 중간에서 데이터를 관리하는 역할, 데이터의 복제나 장애 조치 기능 수행
데이터의 처리량과 안정성을 위해 확장 가능한 방식으로 설계 => 실제 저장소 역할
ZooKeeper: 카프카 클러스터의 구성 정보와 상태를 관리하는 분산 형상 관리도구, 카프카 클러스터의 구성, 토픽의 메타데이터 등을 관리
브로커들간의 리더 선출 등 분산 시스템 관리 => 관리자 역할

차이점: 카프카는 디스크에 이벤트를 저장하여 시스템이 다운되어도 복구 가능, 대규모 트래픽 분산처리가 용이함